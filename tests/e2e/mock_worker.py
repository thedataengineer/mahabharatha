"""Mock worker for E2E testing with deterministic file operations."""

from pathlib import Path

from zerg.protocol_types import ClaudeInvocationResult


class MockWorker:
    """Patches WorkerProtocol.invoke_claude_code with deterministic file I/O.

    For each task, creates and modifies files as specified in the task's
    file manifest, returning predictable success/failure results.

    Args:
        fail_tasks: Optional set of task IDs that should simulate failure.
    """

    def __init__(self, fail_tasks: set[str] | None = None) -> None:
        self.fail_tasks: set[str] = fail_tasks or set()
        self.invocations: list[dict] = []

    def invoke_claude_code(self, task: dict, timeout: int = 300) -> ClaudeInvocationResult:
        """Execute a mock Claude Code invocation with deterministic file operations.

        Creates and modifies files listed in the task manifest, then returns
        a success or failure result based on whether the task ID is in fail_tasks.

        Args:
            task: Task dictionary containing at minimum "id" and optionally
                  "files" with "create" and "modify" lists of file paths.
            timeout: Invocation timeout in seconds (unused in mock).

        Returns:
            ClaudeInvocationResult with deterministic success/failure outcome.
        """
        task_id = task["id"]
        self.invocations.append(task)

        files_spec = task.get("files", {})

        for filepath in files_spec.get("create", []):
            path = Path(filepath)
            path.parent.mkdir(parents=True, exist_ok=True)
            path.write_text(self._generate_content(task, filepath))

        for filepath in files_spec.get("modify", []):
            path = Path(filepath)
            if path.exists():
                existing = path.read_text()
                path.write_text(f"{existing}\n# Modified by task {task_id}\n")

        if task_id in self.fail_tasks:
            return ClaudeInvocationResult(
                success=False,
                stdout="",
                stderr="mock failure",
                exit_code=1,
                duration_ms=50,
                task_id=task_id,
            )

        return ClaudeInvocationResult(
            success=True,
            stdout="mock execution",
            stderr="",
            exit_code=0,
            duration_ms=50,
            task_id=task_id,
        )

    def _generate_content(self, task: dict, filepath: str) -> str:
        """Generate deterministic file content based on file extension.

        Produces syntactically valid Python for .py files and plain text
        for all other file types.

        Args:
            task: Task dictionary providing context for content generation.
            filepath: Target file path used to determine content type.

        Returns:
            Generated file content as a string.
        """
        task_id = task["id"]
        title = task.get("title", "untitled")

        if filepath.endswith(".py"):
            module_doc = f'"""Generated by mock worker for task {task_id}: {title}."""'
            return (
                f"{module_doc}\n"
                f"\n"
                f"\n"
                f"def placeholder() -> None:\n"
                f'    """Placeholder function generated for {task_id}."""\n'
            )

        return f"Generated by mock worker for task {task_id}: {title}\n"
