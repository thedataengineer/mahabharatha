# WM-001: Add metric dataclass types

## Overview
Add new dataclass types for metrics to `mahabharatha/types.py` and extend existing types with timing fields.

## Files to Modify
- `mahabharatha/types.py`

## Requirements

### New Dataclasses

Add these at the end of types.py, before closing:

```python
# ============================================================================
# Metrics types
# ============================================================================


@dataclass
class WorkerMetrics:
    """Aggregated metrics for a single worker."""

    worker_id: int
    initialization_ms: int | None = None
    uptime_ms: int = 0
    tasks_completed: int = 0
    tasks_failed: int = 0
    total_task_duration_ms: int = 0
    avg_task_duration_ms: float = 0.0

    def to_dict(self) -> dict:
        """Convert to dictionary for serialization."""
        return {
            "worker_id": self.worker_id,
            "initialization_ms": self.initialization_ms,
            "uptime_ms": self.uptime_ms,
            "tasks_completed": self.tasks_completed,
            "tasks_failed": self.tasks_failed,
            "total_task_duration_ms": self.total_task_duration_ms,
            "avg_task_duration_ms": self.avg_task_duration_ms,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "WorkerMetrics":
        """Create from dictionary."""
        return cls(
            worker_id=data["worker_id"],
            initialization_ms=data.get("initialization_ms"),
            uptime_ms=data.get("uptime_ms", 0),
            tasks_completed=data.get("tasks_completed", 0),
            tasks_failed=data.get("tasks_failed", 0),
            total_task_duration_ms=data.get("total_task_duration_ms", 0),
            avg_task_duration_ms=data.get("avg_task_duration_ms", 0.0),
        )


@dataclass
class TaskMetrics:
    """Metrics for a single task execution."""

    task_id: str
    queue_wait_ms: int | None = None
    execution_duration_ms: int | None = None
    verification_duration_ms: int | None = None
    total_duration_ms: int | None = None

    def to_dict(self) -> dict:
        """Convert to dictionary for serialization."""
        return {
            "task_id": self.task_id,
            "queue_wait_ms": self.queue_wait_ms,
            "execution_duration_ms": self.execution_duration_ms,
            "verification_duration_ms": self.verification_duration_ms,
            "total_duration_ms": self.total_duration_ms,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "TaskMetrics":
        """Create from dictionary."""
        return cls(
            task_id=data["task_id"],
            queue_wait_ms=data.get("queue_wait_ms"),
            execution_duration_ms=data.get("execution_duration_ms"),
            verification_duration_ms=data.get("verification_duration_ms"),
            total_duration_ms=data.get("total_duration_ms"),
        )


@dataclass
class LevelMetrics:
    """Metrics for a level execution."""

    level: int
    duration_ms: int | None = None
    task_count: int = 0
    completed_count: int = 0
    failed_count: int = 0
    avg_task_duration_ms: float = 0.0
    p50_duration_ms: int = 0
    p95_duration_ms: int = 0

    def to_dict(self) -> dict:
        """Convert to dictionary for serialization."""
        return {
            "level": self.level,
            "duration_ms": self.duration_ms,
            "task_count": self.task_count,
            "completed_count": self.completed_count,
            "failed_count": self.failed_count,
            "avg_task_duration_ms": self.avg_task_duration_ms,
            "p50_duration_ms": self.p50_duration_ms,
            "p95_duration_ms": self.p95_duration_ms,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "LevelMetrics":
        """Create from dictionary."""
        return cls(
            level=data["level"],
            duration_ms=data.get("duration_ms"),
            task_count=data.get("task_count", 0),
            completed_count=data.get("completed_count", 0),
            failed_count=data.get("failed_count", 0),
            avg_task_duration_ms=data.get("avg_task_duration_ms", 0.0),
            p50_duration_ms=data.get("p50_duration_ms", 0),
            p95_duration_ms=data.get("p95_duration_ms", 0),
        )


@dataclass
class FeatureMetrics:
    """Aggregated metrics for entire feature execution."""

    computed_at: datetime
    total_duration_ms: int | None = None
    workers_used: int = 0
    tasks_total: int = 0
    tasks_completed: int = 0
    tasks_failed: int = 0
    levels_completed: int = 0
    worker_metrics: list[WorkerMetrics] = field(default_factory=list)
    level_metrics: list[LevelMetrics] = field(default_factory=list)

    def to_dict(self) -> dict:
        """Convert to dictionary for serialization."""
        return {
            "computed_at": self.computed_at.isoformat(),
            "total_duration_ms": self.total_duration_ms,
            "workers_used": self.workers_used,
            "tasks_total": self.tasks_total,
            "tasks_completed": self.tasks_completed,
            "tasks_failed": self.tasks_failed,
            "levels_completed": self.levels_completed,
            "worker_metrics": [wm.to_dict() for wm in self.worker_metrics],
            "level_metrics": [lm.to_dict() for lm in self.level_metrics],
        }

    @classmethod
    def from_dict(cls, data: dict) -> "FeatureMetrics":
        """Create from dictionary."""
        return cls(
            computed_at=datetime.fromisoformat(data["computed_at"]),
            total_duration_ms=data.get("total_duration_ms"),
            workers_used=data.get("workers_used", 0),
            tasks_total=data.get("tasks_total", 0),
            tasks_completed=data.get("tasks_completed", 0),
            tasks_failed=data.get("tasks_failed", 0),
            levels_completed=data.get("levels_completed", 0),
            worker_metrics=[
                WorkerMetrics.from_dict(wm) for wm in data.get("worker_metrics", [])
            ],
            level_metrics=[
                LevelMetrics.from_dict(lm) for lm in data.get("level_metrics", [])
            ],
        )
```

### Extend WorkerState

Add these fields to the existing WorkerState dataclass:

```python
ready_at: datetime | None = None
last_task_completed_at: datetime | None = None
```

Update `to_dict()` to include:
```python
"ready_at": self.ready_at.isoformat() if self.ready_at else None,
"last_task_completed_at": self.last_task_completed_at.isoformat() if self.last_task_completed_at else None,
```

Update `from_dict()` to parse:
```python
ready_at=(
    datetime.fromisoformat(data["ready_at"]) if data.get("ready_at") else None
),
last_task_completed_at=(
    datetime.fromisoformat(data["last_task_completed_at"])
    if data.get("last_task_completed_at")
    else None
),
```

### Extend TaskExecution TypedDict

Add these optional fields to TaskExecution:

```python
claimed_at: str  # ISO timestamp when task was claimed
duration_ms: int  # Execution duration in milliseconds
```

## Verification

```bash
python -c "from mahabharatha.types import WorkerMetrics, TaskMetrics, LevelMetrics, FeatureMetrics; print('Types OK')"
```

## Acceptance Criteria
- [ ] WorkerMetrics dataclass exists with all fields
- [ ] TaskMetrics dataclass exists with all fields
- [ ] LevelMetrics dataclass exists with all fields
- [ ] FeatureMetrics dataclass exists with all fields
- [ ] WorkerState has ready_at and last_task_completed_at fields
- [ ] TaskExecution has claimed_at and duration_ms fields
- [ ] All to_dict/from_dict methods work correctly
