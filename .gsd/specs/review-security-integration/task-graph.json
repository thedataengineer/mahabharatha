{
  "feature": "review-security-integration",
  "version": "2.0",
  "generated": "2026-02-15",
  "total_tasks": 10,
  "estimated_duration_minutes": 275,
  "max_parallelization": 3,

  "tasks": [
    {
      "id": "TASK-001",
      "title": "Migrate security.py + security_rules.py to zerg/security/ package",
      "description": "Atomic migration: create zerg/security/ package directory. Move scan functions (check_for_secrets, check_sensitive_files, check_for_non_ascii_filenames, check_file_size, get_large_files, run_security_scan, validate_commit_message) and constants (SECRET_PATTERNS, HOOK_PATTERNS, SENSITIVE_FILES) to scanner.py. Move install_hooks/uninstall_hooks to hooks.py. Copy all of security_rules.py to rules.py. Create __init__.py with SecurityFinding and SecurityResult dataclasses plus backward-compat re-exports of all old public names. Delete zerg/security.py and zerg/security_rules.py.",
      "phase": "migration",
      "level": 1,
      "dependencies": [],
      "files": {
        "create": [
          "zerg/security/__init__.py",
          "zerg/security/scanner.py",
          "zerg/security/hooks.py",
          "zerg/security/rules.py"
        ],
        "modify": [],
        "delete": [
          "zerg/security.py",
          "zerg/security_rules.py"
        ],
        "read": []
      },
      "verification": {
        "command": "python -c \"from zerg.security import run_security_scan, check_for_secrets, SECRET_PATTERNS, SENSITIVE_FILES, install_hooks, SecurityResult, SecurityFinding; from zerg.security.rules import detect_project_stack, get_required_rules; print('OK')\"",
        "timeout_seconds": 30
      },
      "estimate_minutes": 40,
      "skills_required": ["python"],
      "consumers": ["TASK-002", "TASK-003", "TASK-004", "TASK-005"],
      "integration_test": "tests/integration/test_review_security.py",
      "context": "## Security Rules (Python)\n- Use parameterized queries for DB access\n- Avoid unsafe deserialization\n- Use subprocess with argument lists, not shell=True\n- Validate file paths to prevent traversal\n\n## Spec Context\nFR-1: Promote zerg/security.py and zerg/security_rules.py into a zerg/security/ package. All existing callers must be updated. __init__.py re-exports: run_security_scan(), SecurityResult, SecurityFinding, check_for_secrets, SECRET_PATTERNS, SENSITIVE_FILES, HOOK_PATTERNS, install_hooks, uninstall_hooks, validate_commit_message, check_file_size, get_large_files, check_sensitive_files, check_for_non_ascii_filenames. FR-3: SecurityFinding dataclass with category, severity, file, line, message, cwe, remediation, pattern_name. SecurityResult with findings, categories_scanned, files_scanned, scan_duration_seconds, passed, summary.\n\n## Dependencies\nNone - this is the foundation task."
    },
    {
      "id": "TASK-002",
      "title": "Create patterns.py with 15 capability pattern registries",
      "description": "Create zerg/security/patterns.py with a SecurityPattern dataclass and PATTERN_REGISTRY dict containing pattern lists for all 15 capability areas: (1) secret detection - consolidate SECRET_PATTERNS + HOOK_PATTERNS.security, (2) injection detection - shell/code/SQL injection, (3) deserialization risks - unsafe deserialization and YAML, (4) cryptographic misuse - MD5/SHA1 for passwords, hardcoded IVs, (5) error handling - bare except, fail-open, stack trace leakage, (6) input validation - unvalidated user input to dangerous sinks, (8) lockfile integrity - missing lockfiles, unpinned deps, (9) license compliance - GPL/AGPL detection, (11) sensitive files - .env, credentials in repo, (12) file permissions - world-writable, (13) env var leakage - logging env vars with secrets, (14) Dockerfile security - running as root, no USER, (15) symlink escape - path traversal. Capabilities 7 (CVE) and 10 (git history) handled elsewhere.",
      "phase": "capabilities",
      "level": 2,
      "dependencies": ["TASK-001"],
      "files": {
        "create": ["zerg/security/patterns.py"],
        "modify": [],
        "read": ["zerg/security/scanner.py"]
      },
      "verification": {
        "command": "python -c \"from zerg.security.patterns import PATTERN_REGISTRY, SecurityPattern; assert len(PATTERN_REGISTRY) >= 13; print(f'OK: {len(PATTERN_REGISTRY)} categories')\"",
        "timeout_seconds": 30
      },
      "estimate_minutes": 30,
      "skills_required": ["python", "regex", "security"],
      "consumers": ["TASK-004"],
      "integration_test": "tests/unit/test_security_engine.py",
      "context": "## Security Rules (Python)\n- All patterns must be pre-compiled with re.compile for performance\n- Avoid ReDoS: no nested quantifiers in patterns\n\n## Spec Context\nFR-2: 15 capability areas. Each pattern carries: name, category, regex, severity, message, cwe (optional), remediation, file_extensions (optional). OWASP CWE mappings: secrets=CWE-798, injection=CWE-78/CWE-94, deserialization=CWE-502, crypto=CWE-327/CWE-328, error-handling=CWE-755. NFR-2: Extensibility - new patterns added to patterns.py without modifying scanner.\n\n## Dependencies\nTASK-001 creates the zerg/security/ package structure. patterns.py is a new standalone module within it."
    },
    {
      "id": "TASK-003",
      "title": "Create cve.py with dependency CVE scanning and fallback",
      "description": "Create zerg/security/cve.py implementing scan_dependencies(project_path) -> list[SecurityFinding]. Strategy: (1) Parse dependency files - requirements.txt, package.json, Cargo.toml, go.mod. (2) Query osv.dev API with 5s timeout per batch. (3) On API failure, fall back to heuristic checks: unpinned versions, missing lockfiles, known-bad version ranges. Supported ecosystems: Python (pip), Node.js (npm), Rust (cargo), Go (go.mod). Import SecurityFinding from zerg.security.__init__.",
      "phase": "capabilities",
      "level": 2,
      "dependencies": ["TASK-001"],
      "files": {
        "create": ["zerg/security/cve.py"],
        "modify": [],
        "read": ["zerg/security/__init__.py"]
      },
      "verification": {
        "command": "python -c \"from zerg.security.cve import scan_dependencies; from pathlib import Path; r = scan_dependencies(Path('.')); print(f'OK: {len(r)} findings')\"",
        "timeout_seconds": 30
      },
      "estimate_minutes": 25,
      "skills_required": ["python", "security"],
      "consumers": ["TASK-004"],
      "integration_test": "tests/unit/test_security_engine.py",
      "context": "## Security Rules (Python)\n- Use urllib/requests with timeout for API calls\n- Validate URL schemes before fetching\n- Handle JSON parse errors gracefully\n\n## Spec Context\nFR-6: CVE Scanning with Fallback. (1) Try osv.dev API first - POST to https://api.osv.dev/v1/querybatch with package list. (2) Fallback to heuristics if offline or API fails: unpinned versions, missing lockfiles, known-bad ranges. (3) Supported ecosystems: PyPI, npm, crates.io, Go. NFR-1: CVE API calls have 5-second timeout with graceful fallback.\n\n## Dependencies\nTASK-001 creates SecurityFinding dataclass in zerg/security/__init__.py."
    },
    {
      "id": "TASK-005",
      "title": "Update all callers to import from zerg.security package",
      "description": "Update imports in three caller files: (1) zerg/commands/security_rules_cmd.py - change 'from zerg.security_rules import ...' to 'from zerg.security.rules import ...'. (2) zerg/context_plugin.py - change 'from zerg.security_rules import filter_rules_for_files, summarize_rules' to 'from zerg.security.rules import ...'. (3) zerg/commands/init.py - change 'from zerg.security_rules import ProjectStack, detect_project_stack, integrate_security_rules' to 'from zerg.security.rules import ...'. Verify all three files still import correctly.",
      "phase": "capabilities",
      "level": 2,
      "dependencies": ["TASK-001"],
      "files": {
        "create": [],
        "modify": [
          "zerg/commands/security_rules_cmd.py",
          "zerg/context_plugin.py",
          "zerg/commands/init.py"
        ],
        "read": []
      },
      "verification": {
        "command": "python -c \"from zerg.commands.security_rules_cmd import security_rules_group; from zerg.context_plugin import ContextEngineeringPlugin; from zerg.commands.init import init; print('OK')\"",
        "timeout_seconds": 30
      },
      "estimate_minutes": 15,
      "skills_required": ["python"],
      "consumers": ["TASK-008"],
      "integration_test": "tests/unit/test_security_rules_cmd.py",
      "context": "## Spec Context\nFR-7: Shared Engine - No Duplication. security_rules_cmd.py CLI uses the same package for rule management. All existing callers must be updated to import from zerg.security (package).\n\n## Dependencies\nTASK-001 creates zerg/security/rules.py from zerg/security_rules.py."
    },
    {
      "id": "TASK-004",
      "title": "Upgrade scanner.py to use patterns.py and return SecurityResult",
      "description": "Modify zerg/security/scanner.py: (1) Import PATTERN_REGISTRY from patterns.py. (2) Import scan_dependencies from cve.py. (3) Rewrite run_security_scan() to iterate all pattern categories, run CVE scan, run git history scan (last 100 commits via git log), collect SecurityFinding objects, assemble SecurityResult. (4) Accept optional parameters: categories (list of category names to scan), files (explicit file list), git_history_depth (default 100). (5) Update __init__.py exports to include the upgraded run_security_scan returning SecurityResult. (6) Keep old dict-returning function as _legacy_scan() for backward compat if needed, but primary API returns SecurityResult.",
      "phase": "wiring",
      "level": 3,
      "dependencies": ["TASK-001", "TASK-002", "TASK-003"],
      "files": {
        "create": [],
        "modify": [
          "zerg/security/scanner.py",
          "zerg/security/__init__.py"
        ],
        "read": [
          "zerg/security/patterns.py",
          "zerg/security/cve.py"
        ]
      },
      "verification": {
        "command": "python -c \"from zerg.security import run_security_scan; r = run_security_scan('.'); assert hasattr(r, 'findings'); assert hasattr(r, 'passed'); assert hasattr(r, 'summary'); print(f'OK: {r.files_scanned} files, {len(r.findings)} findings')\"",
        "timeout_seconds": 60
      },
      "estimate_minutes": 30,
      "skills_required": ["python", "security"],
      "consumers": ["TASK-006", "TASK-007"],
      "integration_test": "tests/unit/test_security_engine.py",
      "context": "## Security Rules (Python)\n- Use subprocess with argument lists for git commands\n- Validate paths to prevent traversal\n- Handle encoding errors gracefully\n\n## Spec Context\nFR-2: Deep Security Scanning Engine with 15 capability areas. Scanner orchestrates: pattern scanning (from patterns.py), CVE scanning (from cve.py), git history scanning (via git log), file permission checks, symlink escape detection. FR-3: run_security_scan() returns SecurityResult dataclass. NFR-1: Full scan of 50 files in <5 seconds (excluding CVE API).\n\n## Dependencies\nTASK-001 created scanner.py with old functions. TASK-002 created patterns.py with PATTERN_REGISTRY. TASK-003 created cve.py with scan_dependencies(). This task wires them together."
    },
    {
      "id": "TASK-008",
      "title": "Update existing test file imports for new package structure",
      "description": "Update imports in existing test files: (1) tests/unit/test_security.py - update 'from zerg.security import ...' to import from specific submodules where appropriate, or verify __init__.py re-exports work. (2) tests/unit/test_security_path_traversal.py - verify import path works. (3) tests/unit/test_security_rules.py - update 'from zerg.security_rules import ...' to 'from zerg.security.rules import ...'. (4) tests/unit/test_security_rules_cmd.py - update if any direct security_rules imports exist. Run all four test files to verify they pass.",
      "phase": "wiring",
      "level": 3,
      "dependencies": ["TASK-001", "TASK-005"],
      "files": {
        "create": [],
        "modify": [
          "tests/unit/test_security.py",
          "tests/unit/test_security_path_traversal.py",
          "tests/unit/test_security_rules.py",
          "tests/unit/test_security_rules_cmd.py"
        ],
        "read": []
      },
      "verification": {
        "command": "python -m pytest tests/unit/test_security.py tests/unit/test_security_path_traversal.py tests/unit/test_security_rules.py tests/unit/test_security_rules_cmd.py -x -q 2>&1 | tail -5",
        "timeout_seconds": 60
      },
      "estimate_minutes": 15,
      "skills_required": ["python", "testing"],
      "consumers": ["TASK-010"],
      "integration_test": null,
      "context": "## Spec Context\nNFR-4: Existing test_security.py migrated to new package structure. All existing tests pass after migration.\n\n## Dependencies\nTASK-001 created the package. TASK-005 updated production callers. This task updates test file imports to match."
    },
    {
      "id": "TASK-006",
      "title": "Integrate security as Stage 3 in review.py with --no-security flag",
      "description": "Modify zerg/commands/review.py: (1) Add 'from zerg.security import run_security_scan, SecurityResult' import. (2) Add security_passed and security_result fields to ReviewResult dataclass. (3) Update overall_passed property to include security_passed. (4) Add _run_security_review() method to ReviewCommand. (5) Call _run_security_review() in run() for 'receive' and 'full' modes. (6) Add --no-security flag to CLI. When set, skip security scan and print warning. (7) Update Rich table output: add 'Stage 3 (Security)' row showing pass/fail/skipped. (8) Show security findings by severity below the table. (9) Remove 'hardcoded_secret' pattern from CodeAnalyzer.PATTERNS (defer to security engine). (10) Update format_result() for both JSON and text formats to include security data.",
      "phase": "integration",
      "level": 4,
      "dependencies": ["TASK-004"],
      "files": {
        "create": [],
        "modify": ["zerg/commands/review.py"],
        "read": ["zerg/security/__init__.py", "zerg/security/scanner.py"]
      },
      "verification": {
        "command": "python -c \"from zerg.commands.review import ReviewResult, ReviewCommand, review; r = ReviewResult(files_reviewed=0, items=[], spec_passed=True, quality_passed=True); assert hasattr(r, 'security_passed'); print('OK')\"",
        "timeout_seconds": 30
      },
      "estimate_minutes": 35,
      "skills_required": ["python", "cli"],
      "consumers": ["TASK-009"],
      "integration_test": "tests/integration/test_review_security.py",
      "context": "## Security Rules (Python)\n- Don't expose stack traces in production error handlers\n- Validate file paths before reading\n\n## Spec Context\nFR-4: Review becomes 3-stage: Spec -> Quality -> Security. Stage 3 invokes run_security_scan(). SecurityResult findings appear in review report. Always-on by default. ReviewResult gains security_passed: bool and security_result: SecurityResult. overall_passed requires all 3 stages to pass. Rich table adds row: Stage 3 (Security). FR-5: --no-security flag, default security ON. When used: prints WARNING. Review output shows Stage 3 (Security): SKIPPED. FR-7: CodeAnalyzer.hardcoded_secret pattern removed - defer to security engine.\n\n## Dependencies\nTASK-004 upgraded scanner.py to return SecurityResult. This task wires the scanner into review.py pipeline."
    },
    {
      "id": "TASK-007",
      "title": "Create unit tests for consolidated security engine",
      "description": "Create tests/unit/test_security_engine.py with comprehensive tests: (1) Pattern registry tests - verify all 13+ categories exist, patterns compile, have required metadata (name, category, severity, cwe). (2) Per-capability positive/negative tests - at least one true positive and one true negative per category. (3) Scanner integration - run_security_scan returns SecurityResult, findings have correct structure. (4) CVE scanner tests - mock osv.dev API success, mock API failure with heuristic fallback, test dependency file parsing for each ecosystem. (5) SecurityResult.passed logic - no critical/high = passed, any critical = failed. (6) Git history scanning - mock git log output, verify secret detection in commit diffs. (7) Performance test - scan of 50 files completes in <5s.",
      "phase": "integration",
      "level": 4,
      "dependencies": ["TASK-004", "TASK-003"],
      "files": {
        "create": ["tests/unit/test_security_engine.py"],
        "modify": [],
        "read": [
          "zerg/security/scanner.py",
          "zerg/security/patterns.py",
          "zerg/security/cve.py"
        ]
      },
      "verification": {
        "command": "python -m pytest tests/unit/test_security_engine.py -x -q 2>&1 | tail -5",
        "timeout_seconds": 120
      },
      "estimate_minutes": 35,
      "skills_required": ["python", "testing", "security"],
      "consumers": [],
      "integration_test": null,
      "context": "## Spec Context\nNFR-4: Unit tests for each capability area. All 15 capability areas have at least one detection pattern. CVE scanning attempts API, falls back to heuristics. Acceptance: No duplicate security patterns exist across codebase.\n\n## Dependencies\nTASK-004 provides the upgraded scanner with SecurityResult. TASK-003 provides cve.py. Tests validate both."
    },
    {
      "id": "TASK-009",
      "title": "Create integration tests for review+security pipeline",
      "description": "Create tests/integration/test_review_security.py: (1) Test full review pipeline shows 3-stage table (Spec, Quality, Security). (2) Test --no-security skips Stage 3 with warning message. (3) Test review JSON output includes security_passed and security findings. (4) Test review with files containing secrets produces security findings. (5) Test overall_passed requires all 3 stages. Also update tests/unit/test_review_cmd.py: (6) Add tests for ReviewResult.security_passed field. (7) Update test_review_full_mode mock to include security_passed. (8) Verify CodeAnalyzer no longer has hardcoded_secret pattern.",
      "phase": "testing",
      "level": 5,
      "dependencies": ["TASK-006"],
      "files": {
        "create": ["tests/integration/test_review_security.py"],
        "modify": ["tests/unit/test_review_cmd.py"],
        "read": ["zerg/commands/review.py"]
      },
      "verification": {
        "command": "python -m pytest tests/integration/test_review_security.py tests/unit/test_review_cmd.py -x -q 2>&1 | tail -5",
        "timeout_seconds": 120
      },
      "estimate_minutes": 25,
      "skills_required": ["python", "testing"],
      "consumers": [],
      "integration_test": null,
      "context": "## Spec Context\nAcceptance: zerg review CLI output shows 3-stage table. zerg review --no-security skips Stage 3 with warning. /z:review and /z:security both call run_security_scan(). CodeAnalyzer in review.py no longer checks for secrets. All existing tests pass. New tests cover consolidated security engine.\n\n## Dependencies\nTASK-006 integrated security as Stage 3 in review.py. This task verifies the integration end-to-end."
    },
    {
      "id": "TASK-010",
      "title": "Update slash commands, docs, and CHANGELOG.md",
      "description": "Update documentation: (1) zerg/data/commands/review.md - add Stage 3 Security description, --no-security flag, 3-stage output example. (2) zerg/data/commands/security.md - reference shared engine with review, note run_security_scan() is the common API. (3) docs/commands-quick.md - update /zerg:review row to mention 3-stage and --no-security. (4) docs/commands-deep.md - update /zerg:review section with 3-stage diagram and security details, update /zerg:security section to note shared engine. (5) CHANGELOG.md - add entry under [Unreleased] in 'Added' category: consolidated security engine with 15 capabilities, review Stage 3 integration, --no-security flag.",
      "phase": "quality",
      "level": 5,
      "dependencies": ["TASK-007", "TASK-008", "TASK-009"],
      "files": {
        "create": [],
        "modify": [
          "zerg/data/commands/review.md",
          "zerg/data/commands/security.md",
          "docs/commands-quick.md",
          "docs/commands-deep.md",
          "CHANGELOG.md"
        ],
        "read": []
      },
      "verification": {
        "command": "grep -q 'no-security' zerg/data/commands/review.md && grep -q 'Stage 3' zerg/data/commands/review.md && grep -q 'Unreleased' CHANGELOG.md && echo 'OK'",
        "timeout_seconds": 30
      },
      "estimate_minutes": 25,
      "skills_required": ["documentation"],
      "consumers": [],
      "integration_test": null,
      "context": "## Spec Context\nSection 11 Documentation Impact: review.md - add Stage 3, --no-security flag. security.md - reference shared engine. commands-quick.md - add --no-security flag. commands-deep.md - new 3-stage diagram. CHANGELOG.md - feature entry under [Unreleased]. All doc changes reflect the unified security engine and review integration.\n\n## Dependencies\nAll implementation and testing tasks complete. This is the final quality/documentation pass."
    }
  ],

  "levels": {
    "1": {
      "name": "migration",
      "tasks": ["TASK-001"],
      "parallel": false,
      "estimated_minutes": 40
    },
    "2": {
      "name": "capabilities",
      "tasks": ["TASK-002", "TASK-003", "TASK-005"],
      "parallel": true,
      "estimated_minutes": 30,
      "depends_on_levels": [1]
    },
    "3": {
      "name": "wiring",
      "tasks": ["TASK-004", "TASK-008"],
      "parallel": true,
      "estimated_minutes": 30,
      "depends_on_levels": [2]
    },
    "4": {
      "name": "integration",
      "tasks": ["TASK-006", "TASK-007"],
      "parallel": true,
      "estimated_minutes": 35,
      "depends_on_levels": [3]
    },
    "5": {
      "name": "quality",
      "tasks": ["TASK-009", "TASK-010"],
      "parallel": true,
      "estimated_minutes": 25,
      "depends_on_levels": [4]
    }
  },

  "conflict_matrix": {
    "description": "Tasks that cannot run in parallel due to shared files. Within each level, no file conflicts exist.",
    "conflicts": [
      {
        "file": "zerg/security/scanner.py",
        "tasks": ["TASK-001", "TASK-004"],
        "resolution": "Sequential levels: TASK-001 (L1) creates, TASK-004 (L3) modifies"
      },
      {
        "file": "zerg/security/__init__.py",
        "tasks": ["TASK-001", "TASK-004"],
        "resolution": "Sequential levels: TASK-001 (L1) creates, TASK-004 (L3) modifies"
      }
    ]
  }
}
