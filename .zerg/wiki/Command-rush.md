# /zerg:rush

Launch parallel workers to execute the task graph.

## Synopsis

```
/zerg:rush [--workers N] [--resume] [--mode container|subprocess]
```

## Description

`/zerg:rush` is the main execution command. It reads the task graph generated by `/zerg:design`, partitions tasks across workers, creates git worktrees for isolation, and launches parallel Claude Code instances to execute tasks level by level.

### Launch Protocol

The command follows a six-step protocol:

1. **Analyze Task Graph** -- Reads `task-graph.json` to determine total tasks and maximum parallelization. Adjusts worker count down if it exceeds the widest level.

2. **Create Worker Branches** -- Creates a base branch `zerg/<feature>/base` and a dedicated git worktree for each worker at `../.zerg-worktrees/<feature>/worker-<id>`.

3. **Partition Tasks** -- Assigns tasks to workers based on dependency level, file ownership, and load balancing. Writes assignments to `worker-assignments.json`.

4. **Register Tasks** -- Creates Claude Code Tasks for every task in the graph with `[L<level>] <title>` subject format. Wires dependency chains using `blockedBy`. Falls back to state JSON if the Task system is unavailable.

5. **Launch Workers** -- Starts worker containers (or subprocesses) with environment variables for worker ID, feature name, branch, port, and `CLAUDE_CODE_TASK_LIST_ID`. Each worker runs `/zerg:worker` to begin execution.

6. **Start Orchestrator** -- Launches the orchestration process that monitors worker progress, triggers merges between levels, and handles failures.

### Execution Model

- Workers within the same level execute in parallel.
- All workers must complete their current level before any worker starts the next level.
- After each level completes, the orchestrator triggers a merge operation.
- Each worker operates in its own git worktree to prevent file conflicts.

### Resume Mode

When run with `--resume`, the command checks for existing Claude Code Tasks and state files. It only creates tasks that do not already exist, allowing execution to continue from where it left off after a stop or crash.

## Options

| Option | Description |
|--------|-------------|
| `--workers N` | Number of parallel workers to launch (default: 5, max: 10) |
| `--resume` | Resume a previously stopped or crashed execution |
| `--mode container\|subprocess` | Execution mode for workers (default depends on configuration) |

## Prerequisites

- `/zerg:design` must have been run
- `task-graph.json` must exist in `.gsd/specs/<feature>/`
- For container mode: Docker must be running and the devcontainer image must be built

## Examples

```bash
# Launch with default 5 workers
/zerg:rush

# Launch with 3 workers
/zerg:rush --workers 3

# Resume after a stop
/zerg:rush --resume

# Resume with a different worker count
/zerg:rush --resume --workers 3
```

## Monitoring

The rush command occupies its terminal session. To monitor progress, open a separate terminal:

```bash
# Recommended: live TUI dashboard
/zerg:status --dashboard

# Text-based auto-refresh
/zerg:status --watch --interval 2

# One-shot status check
/zerg:status
```

## Output

During execution, the following files are created or updated:

```
.gsd/specs/<feature>/
  worker-assignments.json    # Task-to-worker mapping

.zerg/
  .orchestrator.pid          # Orchestrator process ID
  state/<feature>.json       # Execution state (supplementary to Task system)
  logs/
    workers/worker-<id>.jsonl  # Structured worker logs
    orchestrator.jsonl         # Orchestrator log
```

## See Also

- [[Command-design]] -- Must complete before rush
- [[Command-status]] -- Monitor execution progress
- [[Command-logs]] -- View worker output
- [[Command-stop]] -- Halt execution
- [[Command-merge]] -- Manually trigger level merges
- [[Command-Reference]] -- Full command index
