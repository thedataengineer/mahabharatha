# COV-002: Create MockStateManager for state.py testing

## Overview
Create comprehensive mock StateManager in tests/mocks/mock_state.py with full state simulation capabilities.

## Files to Create
- `tests/mocks/mock_state.py`

## Requirements

### MockStateManager Class

```python
from typing import Any
from datetime import datetime
from mahabharatha.constants import TaskStatus, LevelStatus, WorkerStatus
from mahabharatha.types import WorkerState


class MockStateManager:
    """Mock StateManager for testing state.py edge cases."""

    def __init__(self, feature: str, initial_state: dict | None = None):
        """Initialize mock with optional initial state."""
        self.feature = feature
        self._state = initial_state or {
            "workers": {},
            "tasks": {},
            "levels": {},
            "events": [],
        }
        self._save_calls: list[dict] = []
        self._load_calls: list[dict] = []
        self._fail_save: bool = False
        self._fail_load: bool = False

    def configure(
        self,
        fail_save: bool = False,
        fail_load: bool = False,
    ) -> None:
        """Configure mock behavior."""
        self._fail_save = fail_save
        self._fail_load = fail_load

    def set_worker_state(self, worker: WorkerState) -> None:
        """Set worker state with tracking."""
        self._state["workers"][str(worker.worker_id)] = {
            "status": worker.status.value,
            "current_task": worker.current_task,
        }

    def get_worker_state(self, worker_id: int) -> WorkerState | None:
        """Get worker state by ID."""
        data = self._state["workers"].get(str(worker_id))
        if not data:
            return None
        return WorkerState(
            worker_id=worker_id,
            status=WorkerStatus(data["status"]),
            current_task=data.get("current_task"),
        )

    def set_task_status(self, task_id: str, status: TaskStatus) -> None:
        """Set task status with tracking."""
        if task_id not in self._state["tasks"]:
            self._state["tasks"][task_id] = {}
        self._state["tasks"][task_id]["status"] = status.value

    def get_task_status(self, task_id: str) -> TaskStatus | None:
        """Get task status by ID."""
        task = self._state["tasks"].get(task_id)
        if not task:
            return None
        return TaskStatus(task["status"])

    def append_event(self, event_type: str, data: dict) -> None:
        """Append event to history."""
        self._state["events"].append({
            "type": event_type,
            "data": data,
            "timestamp": datetime.now().isoformat(),
        })

    def get_events(self, event_type: str | None = None) -> list[dict]:
        """Get events, optionally filtered by type."""
        if event_type is None:
            return self._state["events"]
        return [e for e in self._state["events"] if e["type"] == event_type]

    def save(self) -> None:
        """Save state with configurable failure."""
        self._save_calls.append({"timestamp": datetime.now()})
        if self._fail_save:
            raise IOError("Simulated save failure")

    def load(self) -> None:
        """Load state with configurable failure."""
        self._load_calls.append({"timestamp": datetime.now()})
        if self._fail_load:
            raise IOError("Simulated load failure")
```

## Verification

```bash
python -c "from tests.mocks.mock_state import MockStateManager; m=MockStateManager('test'); print('OK')"
```

## Acceptance Criteria
- [ ] MockStateManager with configurable initial state
- [ ] Worker state methods with tracking
- [ ] Task state methods with tracking
- [ ] Level state methods with event tracking
- [ ] State persistence simulation with configurable failures
